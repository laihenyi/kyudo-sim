<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>弓道射法模擬 (Right Aim - Corrected)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #222;
            font-family: "Noto Serif JP", serif;
            color: #ecf0f1;
            display: flex;
            height: 100vh;
            user-select: none;
        }

        #app-container {
            display: flex;
            width: 100%;
            height: 100%;
        }

        /* LEFT PANEL */
        #left-panel {
            width: 340px;
            background: #1a1a1a;
            border-right: 2px solid #444;
            display: flex;
            flex-direction: column;
            padding: 20px;
            box-sizing: border-box;
            z-index: 10;
            overflow-y: auto;
        }

        #svg-anim-window {
            width: 100%;
            max-width: 300px;
            height: 320px;
            background: #333;
            border: 4px solid #e67e22;
            border-radius: 4px;
            box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.5);
            margin: 0 auto 15px auto;
            position: relative;
            overflow: hidden;
            flex-shrink: 0;
        }

        .dojo-floor {
            fill: #d2b48c;
            opacity: 0.2;
        }

        #phase-indicator {
            font-family: "Courier New", monospace;
            background: #222;
            color: #f1c40f;
            padding: 10px;
            text-align: center;
            border-radius: 4px;
            margin-bottom: 20px;
            font-weight: bold;
            border: 1px solid #555;
            font-size: 0.9rem;
        }

        .control-group {
            background: #2c3e50;
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 10px;
        }

        label {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            color: #bdc3c7;
            margin-bottom: 5px;
        }

        input[type="range"] {
            width: 100%;
            cursor: pointer;
        }

        button {
            padding: 12px;
            border: none;
            border-radius: 4px;
            font-weight: bold;
            cursor: pointer;
            width: 100%;
            font-size: 1rem;
            transition: 0.2s;
            margin-bottom: 10px;
        }

        #btn-shoot {
            background: #555;
            color: #aaa;
            cursor: not-allowed;
        }

        #btn-shoot.ready {
            background: #c0392b;
            color: white;
            cursor: pointer;
            animation: pulse 2s infinite;
        }

        #btn-shoot.ready:hover {
            background: #e74c3c;
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(192, 57, 43, 0.4);
            }

            70% {
                box-shadow: 0 0 0 10px rgba(192, 57, 43, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(192, 57, 43, 0);
            }
        }

        /* RIGHT PANEL */
        #right-panel {
            flex-grow: 1;
            position: relative;
            background: #333;
        }

        #viewport {
            width: 100%;
            height: 100%;
            background: #87CEEB;
            cursor: crosshair;
            position: relative;
            overflow: hidden;
            touch-action: none;
        }

        #message {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.85);
            color: #f1c40f;
            padding: 15px 30px;
            font-size: 2rem;
            border-radius: 8px;
            border: 2px solid #e67e22;
            display: none;
            z-index: 30;
            pointer-events: none;
            white-space: nowrap;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
        }

        /* ZOOM / REPLAY VIEW */
        #zoom-view {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 220px;
            height: 220px;
            background: #fff;
            border: 4px solid #444;
            border-radius: 50%;
            overflow: hidden;
            display: none;
            z-index: 20;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            transition: all 0.3s ease;
        }

        /* Hawk-Eye Style (Rectangular, Wide) */
        #zoom-view.hawk-eye {
            width: 300px;
            height: 200px;
            border-radius: 8px;
            border-color: #e67e22;
            background: #1e1e1e;
            /* Dark background for replay */
        }

        #zoom-label {
            position: absolute;
            top: 5px;
            left: 5px;
            color: #fff;
            font-family: sans-serif;
            font-size: 0.7rem;
            background: rgba(0, 0, 0, 0.7);
            padding: 2px 5px;
            z-index: 25;
            display: none;
            pointer-events: none;
        }

        .info-text {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.6);
            color: #fff;
            padding: 5px 10px;
            font-size: 0.8rem;
            border-radius: 4px;
            pointer-events: none;
        }

        /* SVG Styles */
        svg {
            width: 100%;
            height: 100%;
            display: block;
        }

        .bow-inner {
            fill: url(#bambooInnerGrad);
        }

        .bow-side {
            fill: url(#bambooSideGrad);
        }

        .bow-grip {
            fill: url(#leatherGrad);
        }

        .ghost-skin {
            fill: url(#skinGrad);
            fill-opacity: 0.3;
            stroke: rgba(255, 255, 255, 0.3);
            stroke-width: 0.8;
        }

        .arrow-shaft-ghost {
            fill: url(#arrowPerspGrad);
            stroke: none;
        }

        .arrow-tip-ghost {
            fill: rgba(30, 30, 30, 0.7);
            stroke: rgba(255, 255, 255, 0.3);
            stroke-width: 0.5;
        }

        .guideline {
            stroke: #ff3333;
            stroke-width: 1;
            stroke-dasharray: 4, 4;
            opacity: 0.5;
            display: none;
        }

        .guideline.active {
            display: block;
        }

        .m-w {
            fill: #fff;
        }

        .m-b {
            fill: #111;
        }

        /* Skeleton Styles */
        .sk-bone {
            stroke: rgba(255, 255, 255, 0.8);
            stroke-width: 3;
            stroke-linecap: round;
            fill: none;
        }

        .sk-joint {
            fill: #e67e22;
            stroke: #fff;
            stroke-width: 1;
        }

        .sk-body {
            fill: rgba(255, 255, 255, 0.1);
            stroke: rgba(255, 255, 255, 0.3);
            stroke-width: 1;
        }

        .sk-head {
            fill: rgba(255, 255, 255, 0.2);
            stroke: #fff;
            stroke-width: 1;
        }

        .sk-bow {
            fill: none;
            stroke: #d2691e;
            stroke-width: 3;
            stroke-linecap: round;
        }

        .sk-string {
            stroke: #fff;
            stroke-width: 1.5;
            opacity: 0.9;
        }

        .sk-arrow {
            stroke: #00ffff;
            stroke-width: 2;
            opacity: 0.9;
        }

        /* Trajectory Animation - FIXED LENGTH */
        .traj-line {
            stroke: #f1c40f;
            stroke-width: 3;
            /* Thicker */
            stroke-dasharray: 1000;
            /* Increased from 100 to 1000 to cover full distance */
            stroke-dashoffset: 1000;
            animation: drawLine 0.6s forwards ease-out;
            fill: none;
            filter: drop-shadow(0 0 2px rgba(0, 0, 0, 0.8));
        }

        .impact-pulse {
            animation: pulseImpact 0.5s forwards;
            transform-origin: center;
            opacity: 0;
            pointer-events: none;
        }

        @keyframes drawLine {
            to {
                stroke-dashoffset: 0;
            }
        }

        @keyframes pulseImpact {
            0% {
                transform: scale(1);
                opacity: 0.8;
            }

            100% {
                transform: scale(3);
                opacity: 0;
            }
        }

        /* Mobile Responsive Tweak */
        @media (max-width: 768px) {
            body {
                overflow: auto;
                height: auto;
            }

            #app-container {
                flex-direction: column;
            }

            #left-panel {
                width: 100%;
                height: auto;
                border-right: none;
                border-bottom: 2px solid #444;
                padding: 15px;
            }

            #right-panel {
                height: 60vh;
                min-height: 400px;
            }

            #message {
                font-size: 1.5rem;
                padding: 10px 20px;
            }
        }
    </style>
</head>

<body>

    <div id="app-container">
        <div id="left-panel">
            <div id="phase-indicator">射法八節</div>
            <div id="svg-anim-window">
                <svg id="archer-svg" viewBox="0 0 300 300" preserveAspectRatio="xMidYMid meet">
                    <defs>
                        <pattern id="grid" width="20" height="20" patternUnits="userSpaceOnUse">
                            <path d="M 20 0 L 0 0 0 20" fill="none" stroke="#333" stroke-width="0.5" />
                        </pattern>
                        <linearGradient id="floorGrad" x1="0" y1="0" x2="0" y2="1">
                            <stop offset="0%" stop-color="#444" />
                            <stop offset="100%" stop-color="#333" />
                        </linearGradient>
                    </defs>
                    <rect width="300" height="300" fill="url(#grid)" />
                    <rect y="250" width="300" height="50" fill="url(#floorGrad)" />

                    <!-- ANKF Standard Style Rig -->
                    <g id="archer-rig" transform="translate(150, 250)">
                        <!-- LEGS: Ashibumi (Wide Stance, ~60 deg) -->
                        <g id="legs">
                            <!-- Hakama: Black, wide pleats -->
                            <path d="M-15,-90 L-35,0 L-10,0 L-5,-60 Z" fill="#1a1a1a" stroke="#000" stroke-width="1.5"
                                stroke-linejoin="round" />
                            <path d="M15,-90 L35,0 L10,0 L5,-60 Z" fill="#1a1a1a" stroke="#000" stroke-width="1.5"
                                stroke-linejoin="round" />
                            <!-- Center Hakama Fold -->
                            <path d="M-15,-90 L-5,-60 L5,-60 L15,-90 Z" fill="#1a1a1a" stroke="#000" stroke-width="1.5"
                                stroke-linejoin="round" />
                            <!-- Tabi (White Socks) -->
                            <path d="M-35,0 L-42,5 L-15,5 L-10,0 Z" fill="#fff" stroke="#ccc" stroke-width="1" />
                            <path d="M35,0 L42,5 L15,5 L10,0 Z" fill="#fff" stroke="#ccc" stroke-width="1" />
                        </g>

                        <!-- TORSO -->
                        <g id="torso-bones" transform="translate(0, -90)">
                            <!-- Gi: White, clean lines -->
                            <path d="M-20,0 L-24,-75 L24,-75 L20,0 Z" fill="#fff" stroke="#ccc" stroke-width="1.5"
                                stroke-linejoin="round" />
                            <!-- Collar (Eri) -->
                            <path d="M-24,-75 L0,-88 L24,-75" fill="none" stroke="#ccc" stroke-width="1" />

                            <!-- HEAD -->
                            <g id="head-grp" transform="translate(0, -82)">
                                <circle cx="0" cy="-8" r="13" fill="#f1c27d" stroke="#dbb070" stroke-width="1" />
                                <!-- Hair: Simple black bun/short hair -->
                                <path d="M-13,-12 Q0,-25 13,-12 L13,-5 Q0,-15 -13,-5 Z" fill="#111" />
                                <!-- Face Profile (Facing Target/Right) -->
                                <path d="M13,-8 L16,-6 L13,-4" fill="none" stroke="#dbb070" stroke-width="1.5" />
                            </g>

                            <!-- LEFT ARM (Bow Hand) -->
                            <g id="arm-l-grp" transform="translate(18, -68)">
                                <!-- Upper Arm (Sleeve) -->
                                <path d="M0,0 L8,32 L-8,32 Z" fill="#fff" stroke="#ccc" stroke-width="1.5"
                                    stroke-linejoin="round" />
                                <g id="fore-l-grp" transform="translate(0, 32)">
                                    <!-- Forearm (Skin) -->
                                    <path d="M0,0 L5,26 L-5,26 Z" fill="#f1c27d" stroke="#dbb070" stroke-width="1" />

                                    <!-- BOW ANCHOR (Moved behind hand for grip effect) -->
                                    <g id="bow-grp" transform="translate(0, 29)">
                                        <!-- Grip (Nigiri) -->
                                        <rect x="-2" y="-6" width="4" height="12" rx="1" fill="#5d4037" stroke="none" />
                                        <!-- Bow Limbs -->
                                        <path id="anim-bow" d="M0,-130 Q0,0 0,80" fill="none" stroke="#d2691e"
                                            stroke-width="4" stroke-linecap="round" />
                                    </g>

                                    <!-- Hand (Fingers wrapping) -->
                                    <circle cx="0" cy="29" r="5" fill="#f1c27d" stroke="#dbb070" stroke-width="1" />
                                    <!-- Thumb Detail -->
                                    <path d="M-2,29 Q0,25 4,27" fill="none" stroke="#dbb070" stroke-width="1"
                                        opacity="0.6" />
                                </g>
                            </g>

                            <!-- RIGHT ARM (Draw Hand) -->
                            <g id="arm-r-grp" transform="translate(-18, -68)">
                                <!-- Upper Arm (Sleeve) -->
                                <path d="M0,0 L8,32 L-8,32 Z" fill="#fff" stroke="#ccc" stroke-width="1.5"
                                    stroke-linejoin="round" />
                                <g id="fore-r-grp" transform="translate(0, 32)">
                                    <!-- Forearm (Skin) -->
                                    <path d="M0,0 L5,26 L-5,26 Z" fill="#f1c27d" stroke="#dbb070" stroke-width="1" />
                                    <!-- Yugake (Glove) - Brown -->
                                    <circle cx="0" cy="29" r="7" fill="#8d6e63" stroke="#5d4037" stroke-width="1" />
                                </g>
                            </g>

                            <!-- Dynamic Strings & Arrow -->
                            <g id="dynamic-visuals">
                                <path id="anim-string" d="M0,0" stroke="#fff" stroke-width="1.5" opacity="0.9"
                                    fill="none" />
                                <line id="anim-arrow-line" x1="0" y1="0" x2="0" y2="0" stroke="#00ffff" stroke-width="2"
                                    opacity="0.9" style="display:none" />
                            </g>
                        </g>
                    </g>
                </svg>
            </div>

            <div class="control-group">
                <label>弓力 <span id="d-pow">15 kg</span></label>
                <input type="range" id="i-pow" min="10" max="30" value="15">
                <label>箭重 <span id="d-wgt">28 g</span></label>
                <input type="range" id="i-wgt" min="20" max="35" value="28">
                <label>左右 (Azuke) <span id="d-ax">280</span></label>
                <input type="range" id="i-ax" min="-100" max="600" value="280">
                <label>上下 (Height) <span id="d-ay">0</span></label>
                <input type="range" id="i-ay" min="-200" max="200" value="0">
                <label>呼吸震幅 (Breath) <span id="d-br">15</span></label>
                <input type="range" id="i-br" min="0" max="15" value="15" step="1">
            </div>
            <button id="btn-shoot" disabled>發 射 (Hanare)</button>
            <div style="margin-top:auto; text-align:center; font-size:0.75rem; color:#888; line-height: 1.6;">
                <strong style="color:#f1c40f">操作指南：</strong><br>
                1. 等待「会」<br>
                2. 長按方向鍵以移動瞄準<br>
                3. 按 <strong>[空白鍵]</strong> 發射<br>
                <span style="color:#aaa; font-size:0.7rem">* 特寫：5公尺內自動開啟落點重播</span>
            </div>
        </div>

        <div id="right-panel">
            <div id="viewport">
                <div id="message"></div>
                <div class="info-text">視角修正：地平線與靶位於箭枕 (拇指) 高度。</div>

                <!-- Combined Zoom / Replay View -->
                <div id="zoom-view">
                    <div id="zoom-label">REPLAY</div>
                    <svg viewBox="0 0 400 300" id="zoom-svg">
                        <defs>
                            <pattern id="grass" width="20" height="20" patternUnits="userSpaceOnUse">
                                <rect width="20" height="20" fill="#2ecc71" />
                                <path d="M0,20 l10,-10 l10,10" fill="none" stroke="#27ae60" stroke-width="1"
                                    opacity="0.5" />
                            </pattern>
                            <linearGradient id="azuchiSand" x1="0%" y1="0%" x2="0%" y2="100%">
                                <stop offset="0%" style="stop-color:#5d4037" />
                                <stop offset="100%" style="stop-color:#3e2723" />
                            </linearGradient>
                        </defs>

                        <!-- MODE 1: TARGET FACE (Hit or very close) -->
                        <g id="z-mode-face" style="display:none">
                            <!-- Centered at 200, 150 -->
                            <g transform="translate(200,150) scale(3.5)">
                                <circle r="36" class="m-w" stroke="#ccc" stroke-width="0.5" />
                                <circle r="29" class="m-b" />
                                <circle r="22" class="m-w" />
                                <circle r="15" class="m-b" />
                                <circle r="8" class="m-w" />
                                <circle r="3" class="m-b" />
                                <g id="z-hits-face"></g>
                            </g>
                        </g>

                        <!-- MODE 2: HAWK-EYE (Azuchi/Ground View) -->
                        <g id="z-mode-hawk" style="display:none">
                            <!-- Background Wall (Concrete Grey) -->
                            <rect x="0" y="0" width="400" height="300" fill="#7f8c8d" />
                            <!-- Wall Band (Blue/Purple) -->
                            <rect x="0" y="100" width="400" height="60" fill="#2c2c54" />

                            <!-- Ground (Grass) -->
                            <rect x="0" y="200" width="400" height="100" fill="url(#grass)" />

                            <!-- Azuchi (Sand Bank) - Darker -->
                            <path d="M50,200 L350,200 L380,300 L20,300 Z" fill="#3e2723" opacity="0.8" />
                            <!-- Shadow/Face -->
                            <path d="M50,200 L350,200 L350,80 L50,80 Z" fill="url(#azuchiSand)" />

                            <!-- Added Grid Lines to Azuchi for depth perception -->
                            <g stroke="rgba(255,255,255,0.15)" stroke-width="1">
                                <line x1="50" y1="120" x2="350" y2="120" />
                                <line x1="50" y1="160" x2="350" y2="160" />
                                <line x1="150" y1="80" x2="150" y2="200" />
                                <line x1="250" y1="80" x2="250" y2="200" />
                            </g>
                            <path d="M30,200 L50,80 L350,80 L370,200 Z" fill="none" stroke="#fff" stroke-width="1"
                                stroke-dasharray="5,5" opacity="0.3" /> <!-- Grid Reference -->

                            <!-- Target Stand & Target (Small) -->
                            <g transform="translate(200, 150)">
                                <!-- Stand Legs -->
                                <line x1="-10" y1="10" x2="-15" y2="50" stroke="#888" stroke-width="2" />
                                <line x1="10" y1="10" x2="15" y2="50" stroke="#888" stroke-width="2" />
                                <!-- Target Face (18cm radius mapped to screen) -->
                                <circle r="18" class="m-w" stroke="#ccc" stroke-width="1" />
                                <circle r="14.5" class="m-b" />
                                <circle r="11" class="m-w" />
                                <circle r="7.5" class="m-b" />
                                <circle r="4" class="m-w" />
                                <circle r="1.5" class="m-b" />
                            </g>

                            <g id="z-hits-hawk"></g>
                        </g>
                    </svg>
                </div>

                <svg class="main-svg" viewBox="0 0 1200 800" preserveAspectRatio="xMidYMid slice">
                    <defs>
                        <linearGradient id="bambooInnerGrad" x1="0%" y1="0%" x2="100%" y2="0%">
                            <stop offset="0%" style="stop-color:#c19a6b" />
                            <stop offset="100%" style="stop-color:#a08050" />
                        </linearGradient>
                        <linearGradient id="bambooSideGrad" x1="0%" y1="0%" x2="100%" y2="0%">
                            <stop offset="0%" style="stop-color:#8B0000" />
                            <stop offset="80%" style="stop-color:#500000" />
                        </linearGradient>
                        <linearGradient id="leatherGrad" x1="0%" y1="0%" x2="100%" y2="0%">
                            <stop offset="0%" style="stop-color:#5d4037" />
                            <stop offset="100%" style="stop-color:#4e342e" />
                        </linearGradient>
                        <linearGradient id="skinGrad" x1="0%" y1="100%" x2="100%" y2="0%">
                            <stop offset="0%" style="stop-color:#e0ac69" />
                            <stop offset="100%" style="stop-color:#ffdbac" />
                        </linearGradient>
                        <linearGradient id="arrowPerspGrad" x1="100%" y1="50%" x2="0%" y2="0%">
                            <stop offset="0%" style="stop-color:#DAA520; stop-opacity:0.1" />
                            <stop offset="40%" style="stop-color:#DAA520; stop-opacity:0.4" />
                            <stop offset="100%" style="stop-color:#DAA520; stop-opacity:0.9" />
                        </linearGradient>
                        <linearGradient id="azuchiGrad" x1="0%" y1="0%" x2="0%" y2="100%">
                            <stop offset="0%" style="stop-color:#3e2723" />
                            <stop offset="100%" style="stop-color:#5d4037" />
                        </linearGradient>
                        <!-- Spotlight Gradient -->
                        <radialGradient id="spotlight" cx="50%" cy="50%" r="50%" fx="50%" fy="50%">
                            <stop offset="0%" style="stop-color:rgba(255,255,255,0.2)" />
                            <stop offset="100%" style="stop-color:rgba(0,0,0,0.3)" />
                        </radialGradient>
                    </defs>

                    <!-- Background Wall (Concrete Grey) -->
                    <rect width="1200" height="380" fill="#7f8c8d" />
                    <!-- Wall Band (Blue/Purple) - Approx 1m high above Azuchi -->
                    <rect y="280" width="1200" height="100" fill="#2c2c54" />

                    <!-- Azuchi -->
                    <rect y="380" width="1200" height="420" fill="url(#azuchiGrad)" />
                    <path d="M0,380 L1200,380 L1200,370 L0,370 Z" fill="#2d1e1b" /> <!-- Darker top edge -->

                    <!-- Spotlight Effect Overlay on Target Area -->
                    <rect x="400" y="300" width="400" height="200" fill="url(#spotlight)"
                        style="mix-blend-mode: overlay;" />

                    <g id="target-grp" transform="translate(600, 380)">
                        <line x1="-5" y1="5" x2="-7" y2="15" stroke="#333" stroke-width="1" />
                        <line x1="5" y1="5" x2="7" y2="15" stroke="#333" stroke-width="1" />
                        <circle r="7.2" class="m-w" />
                        <circle r="5.8" class="m-b" />
                        <circle r="4.4" class="m-w" />
                        <circle r="3.0" class="m-b" />
                        <circle r="1.6" class="m-w" />
                        <circle r="0.6" class="m-b" />
                    </g>

                    <g id="rig-grp" transform="translate(300, 402)">
                        <path d="M-200,400 L-40,80 L10,80 L60,400 Z" class="ghost-skin" />
                        <g id="bow-model" transform="rotate(-5)">
                            <path d="M-20,-50 L-18,-600 L-5,-600 L0,-50 Z" class="bow-inner" />
                            <path d="M0,-50 L-5,-600 L-2,-600 L5,-50 Z" class="bow-side" />
                            <path d="M-20,50 L-22,600 L-7,600 L0,50 Z" class="bow-inner" />
                            <path d="M0,50 L-7,600 L-3,600 L5,50 Z" class="bow-side" />
                            <path d="M-22,-50 L0,-50 L0,50 L-22,50 Z" class="bow-grip" />
                            <rect x="-21" y="-85" width="20" height="35" rx="2" fill="#DAA520" stroke="#8B4513"
                                stroke-width="0.5" />
                        </g>
                        <path d="M8,-24 L400,80 L400,120 L8,-20 Z" class="arrow-shaft-ghost" />
                        <path d="M8,-22 L0,-24 L0,-20 Z" class="arrow-tip-ghost" />
                        <g transform="rotate(-5)">
                            <path d="M-10,20 C0,30 15,25 20,10 C22,0 20,-20 0,-25 C-15,-20 -20,0 -10,20 Z"
                                class="ghost-skin" />
                            <path d="M-25,-30 C-40,-25 -45,-10 -35,0 L-22,-5" class="ghost-skin" />
                            <path d="M-25,-5 C-50,5 -50,30 -25,35 L-22,25" class="ghost-skin" />
                        </g>
                        <line x1="-25" y1="-600" x2="-25" y2="600" stroke="#fff" stroke-width="1" opacity="0.6" />
                        <line x1="4" y1="-200" x2="4" y2="200" class="guideline" />
                        <line x1="8" y1="-22" x2="600" y2="-22" class="guideline" />
                    </g>
                    <circle id="fly-arrow" cx="0" cy="0" r="2" fill="#000" style="display:none" />
                </svg>
            </div>
        </div>
    </div>

    <script>
        const SoundEngine = { ctx: null, init() { window.AudioContext = window.AudioContext || window.webkitAudioContext; this.ctx = new AudioContext(); }, resume() { if (!this.ctx) this.init(); if (this.ctx.state === 'suspended') this.ctx.resume(); }, playHit() { if (!this.ctx) this.init(); if (this.ctx.state === 'suspended') this.ctx.resume(); const t = this.ctx.currentTime; const nb = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.15, this.ctx.sampleRate); const o = nb.getChannelData(0); for (let i = 0; i < o.length; i++)o[i] = Math.random() * 2 - 1; const ns = this.ctx.createBufferSource(); ns.buffer = nb; const nf = this.ctx.createBiquadFilter(); nf.type = 'highpass'; nf.frequency.value = 600; const ng = this.ctx.createGain(); ng.gain.setValueAtTime(0.8, t); ng.gain.exponentialRampToValueAtTime(0.01, t + 0.1); ns.connect(nf); nf.connect(ng); ng.connect(this.ctx.destination); ns.start(t); const os = this.ctx.createOscillator(); os.type = 'triangle'; os.frequency.setValueAtTime(100, t); os.frequency.exponentialRampToValueAtTime(30, t + 0.25); const og = this.ctx.createGain(); og.gain.setValueAtTime(0.6, t); og.gain.exponentialRampToValueAtTime(0.001, t + 0.35); os.connect(og); og.connect(this.ctx.destination); os.start(t); os.stop(t + 0.4); } };

        const SvgArcherEngine = {
            el: {}, state: 'INIT', stage: 0, progress: 0,
            poses: [
                // ANKF Standard Angles (Approximate for 2D projection)
                // la: Left Arm, lf: Left Forearm, ra: Right Arm, rf: Right Forearm
                // bt: Bow Tilt, bb: Bow Bend, hx: Head X Offset

                // 0: Ashibumi (Footing) - Wide stance, bow low, hands at sides/hips
                { la: -20, lf: 10, ra: 20, rf: 10, bt: -10, bb: 0, hx: 0 },
                // 1: Dozukuri (Posture) - Hands at hips, bow vertical, settling
                { la: -30, lf: 40, ra: 30, rf: 40, bt: 0, bb: 0, hx: 0 },
                // 2: Yugamae -> Uchiokoshi (Raising)
                // Starts at Yugamae (Hands at waist, setting grip), then raises.
                // We set the target pose for Uchiokoshi (45 degrees).
                // The transition from 1->2 will show the raise.
                // To show Yugamae explicitly, we might need an intermediate step,
                // but for now let's make Dozukuri (1) look like the Yugamae preparation.
                // Actually, let's make 2 be the TOP of Uchiokoshi.
                // 2: Uchiokoshi (Raising) - Hands high, symmetrical (~45 deg)
                { la: -50, lf: 0, ra: 50, rf: 0, bt: 0, bb: 0, hx: 0 },
                // 3: Daisan (Big Three) - Transition to draw
                // Left arm moves to target, Right hand to forehead
                { la: -60, lf: 10, ra: 20, rf: 90, bt: 10, bb: 10, hx: 2 },
                // 4: Hikiwake (Drawing) - Mid-draw
                // Left arm pushing, Right elbow high, string pulled back
                { la: -75, lf: 10, ra: 40, rf: 120, bt: 5, bb: 40, hx: 5 },
                // 5: Kai (Full Draw) - Max extension
                // Left arm HORIZONTAL (0 degrees = horizontal right), Right elbow back
                { la: 0, lf: 0, ra: 20, rf: 160, bt: 0, bb: 65, hx: 8 },
                // 6: Hanare (Release) - Arms fly apart
                // Chest expands, arms move horizontally outwards
                { la: -100, lf: 0, ra: -30, rf: 170, bt: -20, bb: 0, hx: 8 },
                // 7: Zanshin (Remaining Form) - Hold
                { la: -100, lf: 0, ra: -30, rf: 170, bt: -30, bb: 0, hx: 8 }
            ],
            init() {
                const svg = document.getElementById('archer-svg');
                svg.innerHTML = ''; // Clear existing content

                // Helper Functions
                const createPath = (parent, d, fill, stroke, width) => {
                    const p = document.createElementNS("http://www.w3.org/2000/svg", "path");
                    p.setAttribute("d", d);
                    if (fill) p.setAttribute("fill", fill);
                    if (stroke) { p.setAttribute("stroke", stroke); p.setAttribute("stroke-width", width || 1); }
                    parent.appendChild(p);
                    return p;
                };
                const createGroup = (parent, x, y) => {
                    const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
                    g.setAttribute("transform", `translate(${x},${y})`);
                    parent.appendChild(g);
                    return g;
                };
                const createCircle = (parent, cx, cy, r, fill) => {
                    const c = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                    c.setAttribute("cx", cx); c.setAttribute("cy", cy); c.setAttribute("r", r);
                    c.setAttribute("fill", fill);
                    parent.appendChild(c);
                    return c;
                };

                // We will build the structure:
                // Root -> TorsoGrp -> [Head, Body, Skirt]
                //      -> L_ArmGrp -> [L_Sleeve, L_Forearm, L_Hand, Bow]
                //      -> R_ArmGrp -> [R_Sleeve, R_Forearm, R_Hand, Arrow]
                //      -> R_ArmGrp -> [R_Sleeve, R_Forearm, R_Hand, Arrow]
                //      -> Legs (Static/Base)

                // 1. Torso Group (Create first so we can add children to it)
                this.el.torso = createGroup(svg, 150, 200); // Center of viewBox (300x300)

                // 2. Body (Gi - White)
                this.el.body = createPath(this.el.torso, "M-30,-50 L30,-50 L35,100 L-35,100 Z", "#ecf0f1");

                // 2.5. Muneate (Chest Protector) - Female archer
                // Positioned on left chest area, white with visible border, rounded shape
                this.el.muneate = createPath(this.el.torso, "M-28,-15 Q-15,-20 -5,-15 Q0,0 -5,15 Q-15,20 -28,15 Z", "#ffffff");
                this.el.muneate.setAttribute("stroke", "#bdc3c7");
                this.el.muneate.setAttribute("stroke-width", "2");

                // 3. Hakama (Lower garment) - Now relative to Torso
                // Hakama starts at bottom of Gi (y=100) and extends down to feet (y=200)
                this.el.lLeg = createPath(this.el.torso, "M-30,100 L-40,200", "none", "#2c3e50", 20);
                this.el.rLeg = createPath(this.el.torso, "M30,100 L40,200", "none", "#2c3e50", 20);
                // Hakama Skirt
                this.el.hakama = createPath(this.el.torso, "M-40,100 L40,100 L50,200 L-50,200 Z", "#2c3e50");

                // Head Group (Relative to Torso)
                this.el.headGrp = createGroup(this.el.torso, 0, -60);
                // Neck
                createPath(this.el.headGrp, "M-10,0 L10,0 L10,15 L-10,15 Z", "#f1c27d");
                // Face
                this.el.head = createCircle(this.el.headGrp, 0, -15, 20, "#f1c27d");
                // Hair (Female style with bun)
                // Main hair
                createPath(this.el.headGrp, "M-20,-20 Q0,-40 20,-20 L20,-10 L-20,-10 Z", "#2c3e50");
                // Hair bun (back of head)
                createCircle(this.el.headGrp, 0, -30, 8, "#2c3e50");
                // Side hair strands
                createPath(this.el.headGrp, "M-18,-15 Q-22,-5 -18,0", "none", "#2c3e50", 2);
                createPath(this.el.headGrp, "M18,-15 Q22,-5 18,0", "none", "#2c3e50", 2);

                // 3. Left Arm Group (Bow Hand) - Should be on RIGHT side in mirror view
                this.el.lArm = createGroup(this.el.torso, 30, -40);
                // Sleeve (Gi)
                this.el.lSleeve = createPath(this.el.lArm, "M0,0 L30,10 L25,40 L-5,30 Z", "#ecf0f1");
                // Forearm (Skin)
                this.el.lForearm = createGroup(this.el.lArm, 30, 10); // Elbow pivot
                createPath(this.el.lForearm, "M0,0 L50,0", "none", "#f1c27d", 12); // Arm segment extends right
                // Glove/Hand (Yugake)
                this.el.lHand = createGroup(this.el.lForearm, 50, 0); // Wrist pivot
                createCircle(this.el.lHand, 5, 0, 7, "#8b4513"); // Brown glove (Yugake)

                // Bow Group (Attached to Left Hand)
                this.el.bowGrp = createGroup(this.el.lHand, 0, 0);
                // Bow Body - VERTICAL (correct for Kyudo)
                // Bow extends from top (-130) to bottom (80) in local space
                this.el.bowP = createPath(this.el.bowGrp, "M0,-130 Q0,0 0,80", "none", "#d35400", 4);

                // Grip (Nigiri) - at center (0,0), vertical
                createPath(this.el.bowGrp, "M-2,-10 L2,-10 L2,10 L-2,10 Z", "#2c3e50");

                // String - created in Torso Group (not Bow Group) for correct coordinate system
                // Will be updated dynamically in update() with global coordinates
                this.el.strPath = createPath(this.el.torso, "M0,0 L0,0", "none", "#f0e68c", 3); // Thicker for visibility

                // 4. Right Arm Group (Draw Hand) - Should be on LEFT side in mirror view
                this.el.rArm = createGroup(this.el.torso, -30, -40);
                // Sleeve
                this.el.rSleeve = createPath(this.el.rArm, "M0,0 L-30,10 L-25,40 L5,30 Z", "#ecf0f1");
                // Forearm
                this.el.rForearm = createGroup(this.el.rArm, -30, 10); // Elbow pivot
                createPath(this.el.rForearm, "M0,0 L-50,0", "none", "#f1c27d", 12); // Arm segment extends left
                // Glove/Hand (Yugake - Brown)
                this.el.rHand = createGroup(this.el.rForearm, -50, 0);
                createCircle(this.el.rHand, -5, 0, 8, "#d35400"); // Brown glove
                // Thumb (Torikake) - NEW: Visual Thumb
                createPath(this.el.rHand, "M0,0 L10,5", "none", "#d35400", 5);

                // Arrow (Attached to Right Hand initially)
                this.el.arrGrp = createGroup(this.el.rHand, 0, 0);
                this.el.arrLine = createPath(this.el.arrGrp, "M0,0 L-90,0", "none", "#FFD700", 3); // Shaft - gold color, pointing left toward bow
                createPath(this.el.arrGrp, "M0,0 L10,0", "none", "#fff", 5); // Feathers (Ya) - thicker

                // Map to keys expected by update()
                this.el.al = this.el.lArm;
                this.el.fl = this.el.lForearm;
                this.el.ar = this.el.rArm;
                this.el.fr = this.el.rForearm;
                this.el.bowG = this.el.bowGrp;
                this.el.head = this.el.headGrp; // Group
                this.el.txt = document.getElementById('phase-indicator');

                // Initial Pose Update
                this.update(this.poses[0], this.poses[0], 0);

                // Start animation loop
                this.reset();
                this.loop();
            },
            reset() {
                this.state = 'ANIMATING'; this.stage = 0; this.progress = 0;
                this.updateText(); toggleShootBtn(false); this.el.arrLine.style.display = 'none';
            },
            triggerHanare() { if (this.stage === 5) { this.state = 'ANIMATING'; this.stage = 6; this.progress = 0; } },
            lerp(a, b, t) { return a + (b - a) * t; },
            update(p1, p2, t) {
                const la = this.lerp(p1.la, p2.la, t), lf = this.lerp(p1.lf, p2.lf, t);
                const ra = this.lerp(p1.ra, p2.ra, t), rf = this.lerp(p1.rf, p2.rf, t);
                const bt = this.lerp(p1.bt, p2.bt, t), bb = this.lerp(p1.bb, p2.bb, t);
                const hx = this.lerp(p1.hx, p2.hx, t);

                // Update Transforms with new Pivot Points
                // SWAPPED: Left (bow) on right, Right (draw) on left
                // Left Arm: Pivot at (30, -40) relative to Torso
                this.el.al.setAttribute('transform', `translate(30, -40) rotate(${la})`);
                // Left Forearm: Pivot at (30, 10) relative to Upper Arm
                this.el.fl.setAttribute('transform', `translate(30, 10) rotate(${lf})`);

                // Right Arm: Pivot at (-30, -40) relative to Torso
                this.el.ar.setAttribute('transform', `translate(-30, -40) rotate(${ra})`);
                // Right Forearm: Pivot at (-30, 10) relative to Upper Arm
                this.el.fr.setAttribute('transform', `translate(-30, 10) rotate(${rf})`);

                // Bow & Head
                // Bow & Head
                this.el.bowG.setAttribute('transform', `translate(0, 0) rotate(${bt})`);
                this.el.head.setAttribute('transform', `translate(${hx}, -60)`);

                // Bow Bending Logic - VERTICAL BOW (correct for Kyudo)
                // Grip (center) stays at (0,0) in Bow Group space.
                // Tips move LEFT/RIGHT (X direction) as the bow bends.
                // Bow Space: Y points Up (top to bottom), X points Left/Right.
                // Pulling string moves tips BACK (Negative X - toward archer).
                // Curve Control Point moves FORWARD (Positive X - toward target) to keep curve passing through 0,0.

                // Calculate Tip Displacement based on bb (Bow Bend)
                // bb is approx displacement in pixels.
                const tipDisp = -bb; // Tips move back (toward archer, negative X)
                const ctrlDisp = bb; // Control point moves forward (toward target, positive X)

                // Update Bow Path - VERTICAL
                // Top Tip: (tipDisp, -130), Ctrl: (ctrlDisp, 0), Bottom Tip: (tipDisp, 80)
                this.el.bowP.setAttribute('d', `M${tipDisp},-130 Q${ctrlDisp},0 ${tipDisp},80`);

                // Kinematics for String & Arrow
                const r = Math.PI / 180;
                // Bone Lengths: Upper arm to elbow, Forearm to hand
                // SWAPPED for mirror view: Left (bow) on right, Right (draw) on left
                // Shoulder Offsets: Left(30, -40), Right(-30, -40) relative to torso center (0,0)
                // Elbow offset from shoulder: (30, 10) and (-30, 10)
                // Hand offset from elbow: (50, 0) and (-50, 0)

                // Left Hand Position (Bow Hand - on RIGHT side in mirror view)
                const lsx = 30, lsy = -40; // Shoulder pivot (matches init)
                // Upper arm: from shoulder to elbow at (30, 10) relative to shoulder
                const lex_t = lsx + 30 * Math.cos(la * r) - 10 * Math.sin(la * r);
                const ley_t = lsy + 30 * Math.sin(la * r) + 10 * Math.cos(la * r);

                // Forearm: from elbow to hand at (50, 0) relative to elbow
                const lhx = lex_t + 50 * Math.cos((la + lf) * r);
                const lhy = ley_t + 50 * Math.sin((la + lf) * r);

                // Right Hand Position (Draw Hand - on LEFT side in mirror view)
                const rsx = -30, rsy = -40; // Shoulder pivot (matches init)
                const rex_t = rsx + (-30) * Math.cos(ra * r) - 10 * Math.sin(ra * r);
                const rey_t = rsy + (-30) * Math.sin(ra * r) + 10 * Math.cos(ra * r);

                const rhx = rex_t + (-50) * Math.cos((ra + rf) * r);
                const rhy = rey_t + (-50) * Math.sin((ra + rf) * r);

                // Bow String Anchor Points (Tips) - VERTICAL BOW
                // Need to rotate (tipDisp, -130) and (tipDisp, 80) by bAng
                // Bow is attached to left hand, so its rotation is relative to the hand.
                // The bow's rotation `bt` is applied to the bow group.
                // The hand's rotation is `la + lf`.
                // Total Bow Angle = (la + lf) + bt.
                const bAng = (la + lf + bt) * r; // Total angle of the bow relative to horizontal

                // Rotation Formula: x' = x cos - y sin, y' = x sin + y cos
                const cosB = Math.cos(bAng);
                const sinB = Math.sin(bAng);

                // Top Tip (tx, ty) relative to torso origin
                const t_lx = tipDisp; const t_ly = -130; // Bow local coordinates (VERTICAL)
                const t_rx = t_lx * cosB - t_ly * sinB;
                const t_ry = t_lx * sinB + t_ly * cosB;
                const tx = lhx + t_rx;
                const ty = lhy + t_ry;

                // Bottom Tip (bx, by) relative to torso origin
                const b_lx = tipDisp; const b_ly = 80; // Bow local coordinates (VERTICAL)
                const b_rx = b_lx * cosB - b_ly * sinB;
                const b_ry = b_lx * sinB + b_ly * cosB;
                const bx = lhx + b_rx;
                const by = lhy + b_ry;

                if (bb > 5) {
                    this.el.arrLine.style.display = 'block';
                    this.el.strPath.setAttribute('d', `M${tx},${ty} L${rhx},${rhy} L${bx},${by}`);
                    // Arrow points from right hand toward left hand (bow/target direction)
                    // Calculate angle from right hand to left hand and add 180 to point arrow toward bow
                    const arrowAngle = Math.atan2(lhy - rhy, lhx - rhx) * 180 / Math.PI + 180;
                    this.el.arrGrp.setAttribute('transform', `rotate(${arrowAngle})`);
                    // Use fixed arrow length (90 pixels)
                    const arrowLength = 90;
                    this.el.arrLine.setAttribute('d', `M0,0 L${arrowLength},0`);
                } else {
                    this.el.arrLine.style.display = 'none';
                    this.el.strPath.setAttribute('d', `M${tx},${ty} L${bx},${by}`);
                }
            },
            loop() {
                if (this.state === 'ANIMATING') {
                    this.progress += 0.015;
                    if (this.progress >= 1) {
                        this.progress = 0;
                        if (this.stage < 5) {
                            this.stage++; this.updateText();
                            if (this.stage === 5) { this.state = 'KAI'; toggleShootBtn(true); }
                        } else if (this.stage === 6) {
                            this.stage = 7; this.updateText();
                        } else {
                            this.state = 'ZANSHIN';
                        }
                    }
                    const p1 = this.poses[this.stage];
                    const p2 = this.poses[Math.min(this.stage + 1, 7)];
                    this.update(p1, p2, this.progress);
                } else if (this.state === 'KAI') {
                    const b = Math.sin(Date.now() / 400) * 2;
                    const pk = this.poses[5];
                    this.el.ar.setAttribute('transform', `translate(35, -40) rotate(${pk.ra + b / 3})`); // Adjusted pivot for new model
                    this.update(pk, pk, 0);
                }
                requestAnimationFrame(() => this.loop());
            },
            updateText() { document.getElementById('phase-indicator').innerText = ["足踏み", "胴造り", "打起し", "大三", "引分け", "会 (Kai)", "離れ", "殘心"][this.stage] || "殘心"; }
        };

        (function () {
            const PX_TO_CM = 2.5, DIST_M = 28, G = 9.81;
            let s = { pow: 15, wgt: 28, ax: 280, ay: 0, br: 2, aiming: false, drag: false, lx: 0, ly: 0, vx: 0, vy: 0, swayX: 0, swayY: 0 };
            let heldKeys = {};
            const ACCEL = 0.4, FRICTION = 0.92, MAX_SPEED = 6;

            const el = {
                vp: document.getElementById('viewport'), rig: document.getElementById('rig-grp'), fly: document.getElementById('fly-arrow'),
                zv: document.getElementById('zoom-view'), zSvg: document.getElementById('zoom-svg'),
                zLabel: document.getElementById('zoom-label'),
                zFace: document.getElementById('z-mode-face'), zHawk: document.getElementById('z-mode-hawk'),
                zhFace: document.getElementById('z-hits-face'), zhHawk: document.getElementById('z-hits-hawk'),
                msg: document.getElementById('message'),
                btnS: document.getElementById('btn-shoot'),
                in: { pow: document.getElementById('i-pow'), wgt: document.getElementById('i-wgt'), ax: document.getElementById('i-ax'), ay: document.getElementById('i-ay'), br: document.getElementById('i-br') },
                d: { pow: document.getElementById('d-pow'), wgt: document.getElementById('d-wgt'), ax: document.getElementById('d-ax'), ay: document.getElementById('d-ay'), br: document.getElementById('d-br') }
            };

            function init() { bind(); SvgArcherEngine.init(); loop(); }

            function bind() {
                const upd = k => e => { s[k] = parseInt(e.target.value); el.d[k].innerText = s[k] + (k == 'pow' ? ' kg' : k == 'wgt' ? ' g' : ''); };
                el.in.pow.addEventListener('input', upd('pow')); el.in.wgt.addEventListener('input', upd('wgt'));
                el.in.ax.addEventListener('input', upd('ax')); el.in.ay.addEventListener('input', upd('ay'));
                el.in.br.addEventListener('input', upd('br'));
                el.btnS.addEventListener('click', () => { SoundEngine.resume(); shoot(); });
                window.addEventListener('keydown', e => {
                    if ([' ', 'Enter', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) SoundEngine.resume();
                    if (e.key === ' ' || e.key === 'Enter') { e.preventDefault(); s.aiming ? shoot() : (el.msg.style.display == 'block' ? reset() : null); return; }
                    if (s.aiming && ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) { e.preventDefault(); heldKeys[e.key] = true; }
                });
                window.addEventListener('keyup', e => { if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) { heldKeys[e.key] = false; } });
                el.vp.addEventListener('pointerdown', e => { SoundEngine.resume(); if (s.aiming) { s.drag = true; s.lx = e.clientX; s.ly = e.clientY; el.vp.setPointerCapture(e.pointerId); } });
                el.vp.addEventListener('pointermove', e => { if (s.drag && s.aiming) { const dx = e.clientX - s.lx; const dy = e.clientY - s.ly; s.ax += dx; s.ay += dy; s.lx = e.clientX; s.ly = e.clientY; syncUI(); } });
                el.vp.addEventListener('pointerup', () => s.drag = false);
            }

            function syncUI() { s.ax = Math.min(Math.max(s.ax, -100), 600); s.ay = Math.min(Math.max(s.ay, -200), 200); el.in.ax.value = s.ax; el.in.ay.value = s.ay; }
            window.toggleShootBtn = function (en) { s.aiming = en; el.btnS.disabled = !en; en ? el.btnS.classList.add('ready') : el.btnS.classList.remove('ready'); el.btnS.innerText = en ? "發 射 (Hanare)" : "等待射法流程..."; };

            let t = 0, noiseX = 0, noiseY = 0;
            function loop() {
                t += 0.05;
                if (s.aiming) {
                    if (!s.drag) {
                        if (heldKeys['ArrowLeft']) s.vx -= ACCEL; if (heldKeys['ArrowRight']) s.vx += ACCEL;
                        if (heldKeys['ArrowUp']) s.vy -= ACCEL; if (heldKeys['ArrowDown']) s.vy += ACCEL;
                    }
                    s.vx *= FRICTION; s.vy *= FRICTION;
                    const speed = Math.sqrt(s.vx * s.vx + s.vy * s.vy);
                    if (speed > MAX_SPEED) { const ratio = MAX_SPEED / speed; s.vx *= ratio; s.vy *= ratio; }
                    if (Math.abs(s.vx) < 0.01) s.vx = 0; if (Math.abs(s.vy) < 0.01) s.vy = 0;
                    s.ax += s.vx; s.ay += s.vy;
                    if (Math.abs(s.vx) > 0 || Math.abs(s.vy) > 0) syncUI();

                    const breathY = Math.sin(t * 0.5) * (s.br * 1.5);
                    const tremorMag = s.br * 0.2;
                    const jitterX = (Math.random() - 0.5) * tremorMag;
                    const jitterY = (Math.random() - 0.5) * tremorMag;
                    noiseX += (Math.random() - 0.5) * 0.05 * s.br; noiseY += (Math.random() - 0.5) * 0.05 * s.br;
                    noiseX *= 0.98; noiseY *= 0.98;
                    el.rig.setAttribute('transform', `translate(${300 + s.ax + jitterX + noiseX}, ${402 + s.ay + breathY + jitterY + noiseY})`);
                }
                requestAnimationFrame(loop);
            }

            function shoot() {
                if (!s.aiming) return; s.aiming = false; el.btnS.disabled = true; el.btnS.classList.remove('ready'); heldKeys = {}; s.vx = 0; s.vy = 0;
                SvgArcherEngine.triggerHanare();
                const f = s.pow * 9.81, e = 0.5 * f * 0.85 * 0.75, m = s.wgt / 1000, v0 = Math.sqrt(2 * e / m);
                const tof = DIST_M / v0, drop = (0.5 * G * tof * tof * 100) / PX_TO_CM;

                const breathY = Math.sin(t * 0.5) * (s.br * 1.5);
                const bx = 300 + s.ax + noiseX; const by = 402 + s.ay + breathY + noiseY;
                const pY = 402 - drop; const pX = 596;
                const dX = bx - pX, dY = by - pY;

                el.rig.style.transition = "transform 0.1s ease-out";
                el.rig.style.transform = `translate(${bx - 150}, ${by}) rotate(-30deg)`;
                el.rig.style.opacity = 0.3;
                el.fly.style.display = "block";

                let p = 0, sx = bx + 8, sy = by - 22, ex = 600 + dX, ey = 380 + dY;
                function fLoop() {
                    p += 0.15;
                    const cx = sx + (ex - sx) * p, cy = sy + (ey - sy) * p, r = 3 - 2 * p;
                    el.fly.setAttribute('cx', cx); el.fly.setAttribute('cy', cy); el.fly.setAttribute('r', r);
                    if (p < 1) requestAnimationFrame(fLoop); else result(dX * PX_TO_CM, dY * PX_TO_CM, drop * PX_TO_CM);
                }
                fLoop();
            }

            function result(x, y, dropCm = 100) {
                const distCm = Math.sqrt(x * x + y * y);
                let txt = "外 (Hazure)", c = "#e74c3c";
                let showReplay = false;
                let mode = "";

                el.zhHawk.innerHTML = '';
                el.zLabel.style.display = 'none';

                if (distCm < 18) {
                    // HIT
                    txt = "中 (Atari)!"; c = "#2ecc71";
                    SoundEngine.playHit();
                    if (distCm < 5) { txt = "皆中!!"; c = "#f1c40f"; }
                    mode = 'face';
                    showReplay = true;
                } else if (distCm <= 500) {
                    // MISS BUT CLOSE (5m)
                    txt = "殘念 (Zannen)"; c = "#95a5a6";
                    mode = 'hawk';
                    showReplay = true;
                    el.zLabel.style.display = 'block';
                    el.zLabel.innerText = `REPLAY: X:${x.toFixed(0)} Y:${-y.toFixed(0)}`;
                } else {
                    // FAR MISS
                    txt = "脫靶 (Out of Range)"; c = "#555";
                    showReplay = false;
                }

                el.msg.innerText = txt; el.msg.style.color = c; el.msg.style.display = 'block';

                if (showReplay) {
                    el.zv.style.display = 'block';
                    if (mode === 'face') {
                        el.zv.className = ''; // Circle
                        el.zFace.style.display = 'block';
                        el.zHawk.style.display = 'none';

                        // 1. Create permanent static dot (The Hit)
                        const dot = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                        // Restore scale * 2 for Face View
                        dot.setAttribute("cx", x * 2);
                        dot.setAttribute("cy", y * 2);
                        dot.setAttribute("r", 3);
                        dot.setAttribute("fill", c);
                        dot.setAttribute("stroke", "#000");
                        el.zhFace.appendChild(dot);

                        // 2. Create separate pulse effect (The Animation)
                        const pulse = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                        pulse.setAttribute("cx", x * 2);
                        pulse.setAttribute("cy", y * 2);
                        pulse.setAttribute("r", 3);
                        pulse.setAttribute("fill", c);
                        pulse.classList.add("impact-pulse");
                        el.zhFace.appendChild(pulse);
                    } else {
                        el.zv.className = 'hawk-eye'; // Rect
                        el.zFace.style.display = 'none';
                        el.zHawk.style.display = 'block';

                        // Hawk-Eye Perspective: Shooter's View (From Behind/Bottom)
                        // Origin: Bottom Center (Shooter) -> Target (Depth)

                        const scale = 1.0; // 1cm = 1px
                        // Impact Point on Target Face (hx, hy)
                        // Target Center is at (200, 150)
                        const hx = 200 + (x * scale);
                        const hy = 150 + (y * scale);

                        // Shooter Position (Start of Trajectory)
                        // Fixed at bottom center of the view
                        const sx = 200;
                        const sy = 350; // Below the visible area to simulate coming from "us"

                        // Trajectory Path (Quadratic Bezier)
                        // Control Point: Higher than both to simulate arc (Gravity Drop)
                        // If arrow hits low (positive y), arc needs to be higher.
                        // We use a fixed "Loft" based on distance.
                        // Physics: Peak of parabola is 1/4 of total drop.
                        // dropCm is the total drop in cm.
                        // scale is 1px/cm.
                        const loft = Math.max((dropCm / 4) * scale, 5); // Minimum 5px for visibility
                        const cx = (sx + hx) / 2;
                        const cy = Math.min(sy, hy) - loft;

                        // 1. Draw Trajectory Line (Trace)
                        const trajPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
                        const d = `M${sx},${sy} Q${cx},${cy} ${hx},${hy}`;
                        trajPath.setAttribute("d", d);
                        trajPath.setAttribute("fill", "none");
                        trajPath.setAttribute("stroke", "rgba(241, 196, 15, 0.6)");
                        trajPath.setAttribute("stroke-width", "2");
                        trajPath.setAttribute("stroke-dasharray", "1000");
                        trajPath.setAttribute("stroke-dashoffset", "1000");
                        // Animate Trace
                        const animTrace = document.createElementNS("http://www.w3.org/2000/svg", "animate");
                        animTrace.setAttribute("attributeName", "stroke-dashoffset");
                        animTrace.setAttribute("from", "1000");
                        animTrace.setAttribute("to", "0");
                        animTrace.setAttribute("dur", "0.6s");
                        animTrace.setAttribute("fill", "freeze");
                        animTrace.setAttribute("calcMode", "spline");
                        animTrace.setAttribute("keySplines", "0.25 0.1 0.25 1"); // Ease-out
                        trajPath.appendChild(animTrace);
                        el.zhHawk.appendChild(trajPath);

                        // 2. Animate Arrow Flying
                        const arrowGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");

                        // Arrow Visuals (Simple Shaft + Fletching)
                        // Pointing UP/INTO screen (Vertical in local space)
                        const arrowVis = document.createElementNS("http://www.w3.org/2000/svg", "g");
                        // Shaft
                        const shaft = document.createElementNS("http://www.w3.org/2000/svg", "line");
                        shaft.setAttribute("x1", 0); shaft.setAttribute("y1", 20);
                        shaft.setAttribute("x2", 0); shaft.setAttribute("y2", -20);
                        shaft.setAttribute("stroke", "#DAA520"); shaft.setAttribute("stroke-width", "4");
                        // Fletching
                        const fletch = document.createElementNS("http://www.w3.org/2000/svg", "path");
                        fletch.setAttribute("d", "M-5,20 L0,30 L5,20");
                        fletch.setAttribute("fill", "white");
                        arrowVis.appendChild(shaft); arrowVis.appendChild(fletch);
                        arrowGroup.appendChild(arrowVis);

                        // Motion Path Animation
                        const mPath = document.createElementNS("http://www.w3.org/2000/svg", "animateMotion");
                        mPath.setAttribute("dur", "0.6s");
                        mPath.setAttribute("fill", "freeze");
                        mPath.setAttribute("rotate", "auto"); // Follow path tangent
                        mPath.setAttribute("calcMode", "spline");
                        mPath.setAttribute("keySplines", "0.25 0.1 0.25 1");

                        const mPathRef = document.createElementNS("http://www.w3.org/2000/svg", "mpath");
                        // We need to reference the path. Since we can't easily use ID in shadow DOM or dynamic, 
                        // we'll create a defs path or just use the path data if supported, 
                        // but animateMotion needs an mpath with href to an ID.
                        // Let's generate a unique ID.
                        const pathId = "traj-" + Math.random().toString(36).substr(2, 9);
                        trajPath.setAttribute("id", pathId);
                        mPathRef.setAttribute("href", "#" + pathId);
                        mPath.appendChild(mPathRef);
                        arrowGroup.appendChild(mPath);

                        // Scale Animation (Perspective: Large -> Small)
                        const animScale = document.createElementNS("http://www.w3.org/2000/svg", "animateTransform");
                        animScale.setAttribute("attributeName", "transform");
                        animScale.setAttribute("type", "scale");
                        animScale.setAttribute("from", "2.0"); // Start big (close)
                        animScale.setAttribute("to", "0.4");   // End small (far)
                        animScale.setAttribute("dur", "0.6s");
                        animScale.setAttribute("fill", "freeze");
                        // Note: animateTransform overwrites other transforms, so we wrap arrowVis
                        arrowVis.appendChild(animScale);

                        // Opacity Animation (Fade In)
                        const animOp = document.createElementNS("http://www.w3.org/2000/svg", "animate");
                        animOp.setAttribute("attributeName", "opacity");
                        animOp.setAttribute("from", "0");
                        animOp.setAttribute("to", "1");
                        animOp.setAttribute("dur", "0.1s");
                        animOp.setAttribute("fill", "freeze");
                        arrowGroup.appendChild(animOp);

                        el.zhHawk.appendChild(arrowGroup);

                        // Impact Marker (Delayed)
                        setTimeout(() => {
                            // 1. Permanent Hit Marker
                            const hit = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                            hit.setAttribute("cx", hx); hit.setAttribute("cy", hy);
                            hit.setAttribute("r", 3);
                            hit.setAttribute("fill", c);
                            hit.setAttribute("stroke", "#fff");
                            hit.setAttribute("stroke-width", "1");
                            el.zhHawk.appendChild(hit);

                            // 2. Pulse Effect
                            const pulse = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                            pulse.setAttribute("cx", hx); pulse.setAttribute("cy", hy);
                            pulse.setAttribute("r", 3);
                            pulse.setAttribute("fill", c);
                            pulse.classList.add("impact-pulse");
                            el.zhHawk.appendChild(pulse);

                            // Hide arrow after hit (it sticks in target)
                            arrowGroup.style.display = 'none';
                        }, 600);

                        // Debug: Add target outline circle for visual reference
                        const targetOutline = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                        targetOutline.setAttribute("cx", 200);
                        targetOutline.setAttribute("cy", 150);
                        targetOutline.setAttribute("r", 18); // 18px = 18cm target radius
                        targetOutline.setAttribute("fill", "none");
                        targetOutline.setAttribute("stroke", "rgba(0,255,0,0.4)"); // green reference circle
                        targetOutline.setAttribute("stroke-width", "2");
                        targetOutline.setAttribute("stroke-dasharray", "4,4");
                        el.zhHawk.appendChild(targetOutline);
                    }
                } else {
                    el.zv.style.display = 'none';
                }
            }

            function reset() {
                el.msg.style.display = 'none'; el.zv.style.display = 'none'; el.fly.style.display = 'none';
                el.rig.style.transition = 'none'; el.rig.style.opacity = 1;
                el.rig.setAttribute('transform', `translate(${300 + s.ax}, ${402 + s.ay})`);
                SvgArcherEngine.reset();
            }
            init();
        })();
    </script>
</body>

</html>